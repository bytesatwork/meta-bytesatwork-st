From be26e229716594f8278157f2765c5f35c0098992 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Oliver=20St=C3=A4bler?= <oliver.staebler@bytesatwork.ch>
Date: Tue, 23 Jul 2019 15:46:12 +0200
Subject: [PATCH] board: bytedevkit: Add initial version for bytedevkit

Based on board/st/stmp32mp1.

board: bytedevkit: Update board files with changes from st

This brings in changes up to v2018.11-stm32mp-r4, commit
fd915f073fe23fea3eb509dbc26ac9da1893692a.

arm: bytedevkit: Add target bytedevkit

stmp32mp1: Append target bytedevkit

bytedevkit: upgrade to 2020.01

board: bytedevkit: Introduce choice for RAM size

A new configuration is introduced to select the different RAM
configurations on the byteENGINE STM32MP1x.

board: bytedevkit: Add hwid command

hwid is used for reading and writing the data on the eeprom on byteDEVKIT.

board: bytedevkit: Allow environment on mmc even when booting from nor

Minimize nor flash wear by not writing to it unnecessarily.

board: bytesdevkit: Remove board.c

Move everything to bytedevkit/stm32mp1.c.

board: bytedevkit: Remove SPL support

It is not used with TF-A boot.

board: bytedevkit: Adapt to 2021.10

Use new struct from u-boot API.

Signed-off-by: Gabriel Wicki <gabriel.wicki@bytesatwork.ch>
Signed-off-by: Daniel Ammann <daniel.ammann@bytesatwork.ch>
Signed-off-by: Guy Morand <guy.morand@bytesatwork.ch>
---
 arch/arm/Kconfig                        |   1 +
 arch/arm/mach-stm32mp/Kconfig.15x       |  18 +
 board/bytesatwork/bytedevkit/Kconfig    |  38 ++
 board/bytesatwork/bytedevkit/Makefile   |   9 +
 board/bytesatwork/bytedevkit/hwid.c     | 470 ++++++++++++++++++++++++
 board/bytesatwork/bytedevkit/stm32mp1.c | 338 +++++++++++++++++
 board/bytesatwork/common                |   1 +
 7 files changed, 875 insertions(+)
 create mode 100644 board/bytesatwork/bytedevkit/Kconfig
 create mode 100644 board/bytesatwork/bytedevkit/Makefile
 create mode 100644 board/bytesatwork/bytedevkit/hwid.c
 create mode 100644 board/bytesatwork/bytedevkit/stm32mp1.c
 create mode 120000 board/bytesatwork/common

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 9dd7ea8074..3e1c559852 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -2055,6 +2055,7 @@ source "board/broadcom/bcm963158/Kconfig"
 source "board/broadcom/bcm968360bg/Kconfig"
 source "board/broadcom/bcm968580xref/Kconfig"
 source "board/broadcom/bcmns3/Kconfig"
+source "board/bytesatwork/bytedevkit/Kconfig"
 source "board/cavium/thunderx/Kconfig"
 source "board/eets/pdu001/Kconfig"
 source "board/emulation/qemu-arm/Kconfig"
diff --git a/arch/arm/mach-stm32mp/Kconfig.15x b/arch/arm/mach-stm32mp/Kconfig.15x
index 1887ce15ff..6ebdca10ce 100644
--- a/arch/arm/mach-stm32mp/Kconfig.15x
+++ b/arch/arm/mach-stm32mp/Kconfig.15x
@@ -25,6 +25,24 @@ config TARGET_ST_STM32MP15x
 		Evalulation board (EV1) or Discovery board (DK1 and DK2).
 		The difference between board are managed with devicetree
 
+config TARGET_BYTEDEVKIT
+	bool "bytesatwork byteDEVKIT"
+	select ARCH_SUPPORT_PSCI
+	select BINMAN
+	select CPU_V7A
+	select CPU_V7_HAS_NONSEC
+	select CPU_V7_HAS_VIRT
+	select OF_BOARD_SETUP
+	select PINCTRL_STM32
+	select STM32_RCC
+	select STM32_RESET
+	select STM32_SERIAL
+	select SUPPORT_SPL
+	select SYS_ARCH_TIMER
+	imply CMD_NVEDIT_INFO
+	help
+		Enable byteDEVKIT as target.
+
 config TARGET_DH_STM32MP1_PDK2
 	bool "DH STM32MP1 PDK2"
 	help
diff --git a/board/bytesatwork/bytedevkit/Kconfig b/board/bytesatwork/bytedevkit/Kconfig
new file mode 100644
index 0000000000..cb322a25c5
--- /dev/null
+++ b/board/bytesatwork/bytedevkit/Kconfig
@@ -0,0 +1,38 @@
+if TARGET_BYTEDEVKIT
+
+config SYS_BOARD
+	default "bytedevkit"
+
+config SYS_VENDOR
+	default "bytesatwork"
+
+config SYS_CONFIG_NAME
+	default "bytedevkit"
+
+choice
+	prompt "byteENGINE STM32MP1 DDR size"
+	default BYTEENGINE_STM32MP1_RAM_512
+
+config BYTEENGINE_STM32MP1_RAM_512
+	bool "512MB"
+
+config BYTEENGINE_STM32MP1_RAM_1024
+	bool "1024MB"
+
+endchoice
+
+config CMD_HWID
+       bool "read from and program HWID EEPROM and set env vars"
+       default y
+       help
+	  This option enables the U-Boot CLI command `hwid` which enables
+	  reading out content from the designated HWID (HardWare ID) EEPROM
+	  and programming that ROM.  With that EEPROM byteENGINEs are able to
+	  destinguish on which type of board they run and can dynamically
+	  pass the right Device-Trees to the Kernel.
+
+
+
+source "board/st/common/Kconfig"
+
+endif
diff --git a/board/bytesatwork/bytedevkit/Makefile b/board/bytesatwork/bytedevkit/Makefile
new file mode 100644
index 0000000000..14b7738710
--- /dev/null
+++ b/board/bytesatwork/bytedevkit/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+#
+# Copyright (c) 2019 bytes at work AG. All rights reserved.
+#
+# based on stm32mp1/Makefile:
+# Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+#
+obj-y += stm32mp1.o
+obj-$(CONFIG_CMD_HWID) += hwid.o
diff --git a/board/bytesatwork/bytedevkit/hwid.c b/board/bytesatwork/bytedevkit/hwid.c
new file mode 100644
index 0000000000..3810609751
--- /dev/null
+++ b/board/bytesatwork/bytedevkit/hwid.c
@@ -0,0 +1,470 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2022 bytes at work AG. All rights reserved.
+ *
+ * U-Boot command to read HWID EEPROM module and parse the there-contained
+ * information offers functionality to read hardware identifiers from EEPROM and
+ * write such
+ */
+
+#include <common.h>
+#include <config.h>
+#include <command.h>
+#include <eeprom.h>
+#include <errno.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <u-boot/crc.h>
+#include <vsprintf.h>
+#include <linux/delay.h>
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#define HWID_EEPROM_DEVICE (1)
+#define EEPROM_ROW (16)
+#define MAGIC "byteDEVKIT"
+#define MAGIC_SIZE (16)
+struct bytedevkit_header {
+	/* Header Format for byteDEVKIT 1.3 */
+	char magic[MAGIC_SIZE];	/* "byteDEVKIT", as defined in MAGIC */
+	u32 crc;		/* checksum of the payload */
+	u32 payload_size;	/* size of the header starting here (it's 57) */
+	u8 header_version;
+	u8 major;
+	u8 minor;
+	u8 patch;
+	u32 art_nr;
+	u32 lot;
+	u8 lotseq;
+	char proddate[12];
+	char flashdate[6];
+	char flashuser[6];
+	char uid[16];
+} __packed;
+#define HEADER_PAYLOAD_START (MAGIC_SIZE + sizeof(u32))
+#define HEADER_PAYLOAD_SIZE (sizeof(struct bytedevkit_header) \
+			     - HEADER_PAYLOAD_START)
+#define UNDEFINED (-1)
+#define CURRENT_HEADER_VERSION (1)
+
+static struct bytedevkit_header hwid_eeprom;
+
+#if defined(DEBUG)
+/* DEBUGGING FUNCTIONS */
+static void inspect_args(int argc,  char * const argv[])
+{
+	/* Print the command being called */
+	printf("calling: `hwid");
+	for (int i = 0; i < argc; i++)
+		printf(" %s", argv[i]);
+	printf("`\n");
+}
+#endif
+
+/* UTILITIES */
+static int check_magic_number(void)
+{
+	/* Compare the EEPROM string with our pre-processor #define MAGIC */
+	if (strncmp(hwid_eeprom.magic, MAGIC, 11)) {
+		printf("magic number did NOT have the expected value: \"%s\""
+		       "vs \"%s\"\n\n", hwid_eeprom.magic, MAGIC);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int read_whole_header(void)
+{	/* read the whole EEPROM header and store the info in hwid_eeprom */
+	int ret = eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0,
+			      (uchar *)&hwid_eeprom,
+			      sizeof(struct bytedevkit_header));
+	if (ret)
+		printf("Error accessing HWID EEPROM\n");
+	return ret;
+}
+
+static void set_env_vars(s8 header, s8 major, s8 minor, s8 patch)
+{
+	/* sets the environment variables for byteDEVKIT */
+	char env_string[4] = ""; /* maximum: "255" */
+
+	sprintf(env_string, "%d", header);
+	env_set("board_header", env_string);
+	sprintf(env_string, "%d", major);
+	env_set("board_major", env_string);
+	sprintf(env_string, "%d", minor);
+	env_set("board_minor", env_string);
+	sprintf(env_string, "%d", patch);
+	env_set("board_patch", env_string);
+}
+
+#if defined(DEBUG)
+static int prompt_agreement(void)
+{
+	/* returns zero if the input character is *not* y or Y */
+	char prompt_input = getc();
+
+	printf("%c\n", prompt_input);
+	return (prompt_input == 'y' || prompt_input == 'Y');
+}
+#endif
+
+static int get_header_and_integrity_checks(void)
+{
+	int ret;
+
+	ret = read_whole_header();
+	if (ret) {
+		printf("ERROR while reading header\n");
+		return ret;
+	}
+	ret = check_magic_number();
+	if (ret) {
+		if (ret == -EIO) {
+			/* No HWID EEPROM could be accessed: we assume to be
+			 * running on a byteDEVKIT version 1.2
+			 */
+			set_env_vars(UNDEFINED, 1, 2, UNDEFINED);
+		} else {
+			printf("failed reading magic number from HWID EEPROM\n");
+		}
+		return ret;
+	}
+	if (hwid_eeprom.payload_size != HEADER_PAYLOAD_SIZE) {
+		printf("HWID EEPROM: unexpected payload size: %d != %d\n",
+		       hwid_eeprom.payload_size, HEADER_PAYLOAD_SIZE);
+		return -EINVAL;
+	}
+	if (crc32(0, (u8 *)&hwid_eeprom + HEADER_PAYLOAD_START,
+		  hwid_eeprom.payload_size) != hwid_eeprom.crc) {
+		printf("HWID EEPROM CRC validation failed!\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int write_eeprom(unsigned int addr, uchar *source, unsigned int count)
+{
+	const int block_size = 64; /* as specified by the reference manual */
+	int offset;
+	int ret = 0;
+
+	for (int i = 0; i <= count / block_size; i++) {
+		offset = i * block_size;
+		ret = eeprom_write(addr, offset, source + offset, block_size);
+		if (ret)
+			break;
+		mdelay(5);
+	}
+	return ret;
+}
+
+/* U-BOOT CLI COMMANDS */
+int do_hwid_check(struct cmd_tbl *cmdtp, int flag, int argc,
+		  char * const argv[])
+{
+	/* Checks for presence of an EEPROM on I2C bus. If no EEPROM is found
+	 * we probably operate on a byteDEVKIT 1.1; otherwise we check the
+	 * EEPROM contents for valid data.
+	 * There's no explicit need to call this function; it gets called by
+	 * `hwid get` before setting environment variables.
+	 */
+	int ret;
+
+	ret = get_header_and_integrity_checks();
+	if (ret) {
+		printf("error checking header\n");
+	} else {
+		set_env_vars(hwid_eeprom.header_version, hwid_eeprom.major,
+			     hwid_eeprom.minor, hwid_eeprom.patch);
+	}
+	return ret;
+}
+
+int do_prod_data(struct cmd_tbl *cmdtp, int flag, int argc,
+		 char * const argv[])
+{
+	int ret;
+
+	ret = get_header_and_integrity_checks();
+	if (ret)
+		printf("WARNING: error checking header\n");
+
+	printf("\tPRODUCTION DATA\n");
+	printf("art_nr: %d\n", hwid_eeprom.art_nr);
+	printf("lot: %d\n", hwid_eeprom.lot);
+	printf("lotseq: %d\n", hwid_eeprom.lotseq);
+	printf("proddate: %s\n", hwid_eeprom.proddate);
+	printf("flashdate: %s\n", hwid_eeprom.flashdate);
+	printf("flashuser: %s\n", hwid_eeprom.flashuser);
+	printf("uid: %s\n", hwid_eeprom.uid);
+
+	return ret;
+}
+
+int do_hwid_set(struct cmd_tbl *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	/* Write the magic-number, the CRC, the size of the header, as well as
+	 * the values for header version, major version, minor version and patch
+	 * to the EEPROM.
+	 */
+	struct bytedevkit_header new_header;
+	int ret;
+
+	if (argc != 11) {
+		printf("wrong number of arguments!\n");
+		return CMD_RET_USAGE;
+	}
+
+	strlcpy(new_header.magic, MAGIC, MAGIC_SIZE);
+	new_header.payload_size = (u32)HEADER_PAYLOAD_SIZE;
+	new_header.header_version = CURRENT_HEADER_VERSION;
+	new_header.major = (u8)simple_strtoul(argv[1], NULL, 10);
+	new_header.minor = (u8)simple_strtoul(argv[2], NULL, 10);
+	new_header.patch = (u8)simple_strtoul(argv[3], NULL, 10);
+	new_header.art_nr = (u32)simple_strtoul(argv[4], NULL, 10);
+	new_header.lot = (u32)simple_strtoul(argv[5], NULL, 10);
+	new_header.lotseq = (u8)simple_strtoul(argv[6], NULL, 10);
+	strlcpy(new_header.proddate, argv[7], 12);
+	strlcpy(new_header.flashdate, argv[8], 6);
+	strlcpy(new_header.flashuser, argv[9], 6);
+	strlcpy(new_header.uid, argv[10], 16);
+	new_header.crc = crc32(0, (u8 *)&new_header + HEADER_PAYLOAD_START,
+			       new_header.payload_size);
+
+	ret = write_eeprom(CONFIG_SYS_I2C_EEPROM_ADDR, (uchar *)&new_header,
+			   (sizeof(struct bytedevkit_header)));
+	if (!ret)
+		printf("HWID EEPROM was flashed successfully\n");
+	return ret;
+}
+
+#if defined(DEBUG)
+int do_eeprom_reset(struct cmd_tbl *cmdtp, int flag, int argc,
+		    char * const argv[])
+{
+	/* reset COUNT rows (16 bytes) of EEPROM starting at OFFSET */
+
+	char reset_string[EEPROM_ROW];
+	char byte;
+	int offset;
+	int count;
+	int ret;
+
+	if (argc != 4)
+		return CMD_RET_USAGE;
+
+	offset = simple_strtoul(argv[1], NULL, 16);
+	byte = simple_strtoul(argv[2], NULL, 16);
+	count = simple_strtoul(argv[3], NULL, 10);
+
+	for (int i = 0; i < EEPROM_ROW; i++)
+		reset_string[i] = byte;
+
+	for (int i = 0; i < count; i++) {
+		ret = eeprom_write(CONFIG_SYS_I2C_EEPROM_ADDR,
+				   offset + EEPROM_ROW * i,
+				   (uchar *)&reset_string,
+				   sizeof(reset_string));
+		if (ret)
+			return ret;
+		mdelay(5);
+	}
+
+	return 0;
+}
+
+int do_hwid_read(struct cmd_tbl *cmdtp, int flag, int argc,
+		 char * const argv[])
+{
+	/* debug-interface to view COUNT bytes of EEPROM (like `i2c md`) */
+	u8 byte;
+	int count;
+	int ret;
+
+	if (argc != 2)
+		return -EINVAL;
+
+	count = simple_strtoul(argv[1], NULL, 10);
+
+	for (int i = 0; i < count; i++) {
+		if (i % EEPROM_ROW == 0)
+			printf("\n%04x   ", i);
+
+		ret = eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, i, &byte, 1);
+
+		if (ret != 0) {
+			printf("Error reading from eeprom\n");
+			return -EINVAL;
+		}
+		printf("%02x ", byte);
+	}
+
+	printf("\nfinished reading raw content from EEPROM\n");
+
+	return 0;
+};
+
+int do_e2e_test(struct cmd_tbl *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	/* Run an End-To-End Test over the whole module
+	 *
+	 * First we erase data in the EEPROM, we check back whether this
+	 * succeeded.  We then write some header info into the EEPROM and check
+	 * back.  Finally we read the data in the EEPROM, check if for validity
+	 * and sets.  Environment Variables accordingly. We check that back as
+	 * well.
+	 */
+
+	int ret;
+	int e2e_argc;
+	char *e2e_argv[12];
+
+	printf("\n\t\tE2E TEST\n\n");
+
+	printf("Reset EEPROM? (yN) ");
+	if (!prompt_agreement()) {
+		printf("aborted\n");
+		return -UNDEFINED;
+	}
+
+	printf("\tRESETTING EEPROM\n");
+	e2e_argc = 4;
+	e2e_argv[0] = "eeprom_reset";
+	e2e_argv[1] = "0";
+	e2e_argv[2] = "ff";
+	e2e_argv[3] = "4";
+	inspect_args(e2e_argc, e2e_argv);
+	ret = do_eeprom_reset(cmdtp, flag, e2e_argc, e2e_argv);
+	if (ret) {
+		printf("FAILURE (code: %d)\n", ret);
+		return ret;
+	}
+
+	printf("\tREADING EEPROM\n");
+	e2e_argc = 2;
+	e2e_argv[0] = "read";
+	e2e_argv[1] = "32";
+	inspect_args(e2e_argc, e2e_argv);
+	ret = do_hwid_read(cmdtp, flag, e2e_argc, e2e_argv);
+	if (ret) {
+		printf("FAILURE (code: %d)\n", ret);
+		return ret;
+	}
+
+	printf("\tFLASH HEADER\n");
+	e2e_argc = 12;
+	e2e_argv[0] = "set";
+	e2e_argv[1] = "0";			/* header */
+	e2e_argv[2] = "1";			/* major */
+	e2e_argv[3] = "3";			/* minor */
+	e2e_argv[4] = "0";			/* patch */
+	e2e_argv[5] = "888053501";		/* art_nr */
+	e2e_argv[6] = "103";			/* lot */
+	e2e_argv[7] = "1";			/* lotseq */
+	e2e_argv[8] = "2022-01-01";		/* proddate */
+	e2e_argv[9] = "19/20";			/* flashdate */
+	e2e_argv[10] = "sdu";			/* flashuser */
+	e2e_argv[11] = "1804270009737";		/* uid */
+
+	inspect_args(e2e_argc, e2e_argv);
+	ret = do_hwid_set(cmdtp, flag, e2e_argc, e2e_argv);
+	if (ret) {
+		printf("FAILURE (code: %d)\n", ret);
+		return ret;
+	}
+
+	printf("\tCHECKING VALIDITY OF EEPROM CONTENT\n");
+	e2e_argc = 1;
+	e2e_argv[0] = "check";
+	inspect_args(e2e_argc, e2e_argv);
+	ret = do_hwid_check(cmdtp, flag, e2e_argc, e2e_argv);
+	if (ret) {
+		printf("FAILURE (code: %d)\n", ret);
+		return ret;
+	}
+
+	printf("\n\n");
+
+	return 0;
+};
+
+int do_info(struct cmd_tbl *cmdtp, int flag, int argc,
+	    char * const argv[])
+{
+	printf("Information about this module:\n");
+	printf("HWID EEPROM DEVICE: %d\n", HWID_EEPROM_DEVICE);
+	printf("HWID EEPROM ADDR: 0x%X\n", CONFIG_SYS_I2C_EEPROM_ADDR);
+	printf("MAGIC: \"%s\"\n", MAGIC);
+	printf("HEADER PAYLOAD START: %d\n", HEADER_PAYLOAD_START);
+	printf("HEADER PAYLOAD SIZE: %d\n", HEADER_PAYLOAD_SIZE);
+	printf("UNDEFINED: %d\n", UNDEFINED);
+	return 0;
+}
+#endif
+
+static struct cmd_tbl cmd_hwid_sub[] = {
+	U_BOOT_CMD_MKENT(check, 1, 1, do_hwid_check, "", ""),
+	U_BOOT_CMD_MKENT(prod_data, 1, 1, do_prod_data, "", ""),
+	U_BOOT_CMD_MKENT(set, 11, 1, do_hwid_set, "", ""),
+#if defined(DEBUG)
+	U_BOOT_CMD_MKENT(eeprom_reset, 1, 1, do_eeprom_reset, "", ""),
+	U_BOOT_CMD_MKENT(read, 2, 1, do_hwid_read, "", ""),
+	U_BOOT_CMD_MKENT(e2e, 1, 1, do_e2e_test, "", ""),
+	U_BOOT_CMD_MKENT(info, 1, 1, do_info, "", "")
+#endif
+};
+
+int do_hwid(struct cmd_tbl *cmdtp, int flag,  int argc,  char * const argv[])
+{
+	struct cmd_tbl *cmd;
+
+	if (argc < 2) {
+		/* abort and show help if no subcommand is entered */
+		return CMD_RET_USAGE;
+	}
+
+	argc--; /* decrease argument counter */
+	argv++; /* move argument pointer past first argument */
+
+	cmd = find_cmd_tbl(argv[0], cmd_hwid_sub, ARRAY_SIZE(cmd_hwid_sub));
+	if (cmd) {
+		eeprom_init(HWID_EEPROM_DEVICE);
+		return cmd->cmd(cmdtp, flag, argc, argv);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	/* Here the entry-command for the U-Boot CLI is defined.  Just enter
+	 * `hwid` and find yourself within a quasi-guided text-based user
+	 * interface as you are probably already used to from U-Boot.
+	 */
+	hwid, 12, 0, do_hwid,
+	"HWID EEPROM module. commands are: `check`, `prod_data`, `set`, "
+#if defined(DEBUG)
+	"`get`, `eeprom_reset`, `read` and `e2e`"
+#endif
+	,
+	"check - checks the connection to the EEPROM module and the general "
+	"validity\n\n"
+	"hwid prod_data - prints production data\n\n"
+	"hwid set MAJOR MINOR PATCH ART_NR LOT LOTSEQ PRODDATE FLASHDATE "
+	"FLASHUSER UID - writes these values into HWID EEPROM\n\n"
+#if defined(DEBUG)
+	"hwid eeprom_reset OFFSET BYTE COUNT - resets COUNT rows (16 Bytes) "
+	"OFFSET (in hex) in HWID EEPROM to BYTE (passed in hex).\n\n"
+	"hwid read COUNT - reads COUNT (decimal) bytes from HWID EEPROM and "
+	"writes to stdout\n\n"
+	"hwid e2e - test this whole module (this will modify EEPROM and may "
+	"delete precious data\n\n"
+	"hwid info - information about constants in this module\n\n"
+	"eeprom_reset, read, e2e and info subcommands are intended for "
+	"debugging purposes\n\n"
+#endif
+	)
diff --git a/board/bytesatwork/bytedevkit/stm32mp1.c b/board/bytesatwork/bytedevkit/stm32mp1.c
new file mode 100644
index 0000000000..268fb1fc81
--- /dev/null
+++ b/board/bytesatwork/bytedevkit/stm32mp1.c
@@ -0,0 +1,338 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_BOARD
+
+#include <common.h>
+#include <adc.h>
+#include <bootm.h>
+#include <clk.h>
+#include <config.h>
+#include <dm.h>
+#include <env.h>
+#include <env_internal.h>
+#include <fdt_simplefb.h>
+#include <fdt_support.h>
+#include <g_dnl.h>
+#include <generic-phy.h>
+#include <hang.h>
+#include <i2c.h>
+#include <regmap.h>
+#include <init.h>
+#include <led.h>
+#include <log.h>
+#include <malloc.h>
+#include <misc.h>
+#include <mtd_node.h>
+#include <net.h>
+#include <netdev.h>
+#include <phy.h>
+#include <remoteproc.h>
+#include <reset.h>
+#include <syscon.h>
+#include <usb.h>
+#include <watchdog.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
+#include <jffs2/load_kernel.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/iopoll.h>
+#include <power/regulator.h>
+#include <tee/optee.h>
+#include <usb/dwc2_udc.h>
+
+/* SYSCFG registers */
+#define SYSCFG_BOOTR		0x00
+#define SYSCFG_PMCSETR		0x04
+#define SYSCFG_IOCTRLSETR	0x18
+#define SYSCFG_ICNR		0x1C
+#define SYSCFG_CMPCR		0x20
+#define SYSCFG_CMPENSETR	0x24
+#define SYSCFG_PMCCLRR		0x44
+
+#define SYSCFG_BOOTR_BOOT_MASK		GENMASK(2, 0)
+#define SYSCFG_BOOTR_BOOTPD_SHIFT	4
+
+#define SYSCFG_IOCTRLSETR_HSLVEN_TRACE		BIT(0)
+#define SYSCFG_IOCTRLSETR_HSLVEN_QUADSPI	BIT(1)
+#define SYSCFG_IOCTRLSETR_HSLVEN_ETH		BIT(2)
+#define SYSCFG_IOCTRLSETR_HSLVEN_SDMMC		BIT(3)
+#define SYSCFG_IOCTRLSETR_HSLVEN_SPI		BIT(4)
+
+#define SYSCFG_CMPCR_SW_CTRL		BIT(1)
+#define SYSCFG_CMPCR_READY		BIT(8)
+
+#define SYSCFG_CMPENSETR_MPU_EN		BIT(0)
+
+#define SYSCFG_PMCSETR_ETH_CLK_SEL	BIT(16)
+#define SYSCFG_PMCSETR_ETH_REF_CLK_SEL	BIT(17)
+
+#define SYSCFG_PMCSETR_ETH_SELMII	BIT(20)
+
+#define SYSCFG_PMCSETR_ETH_SEL_MASK	GENMASK(23, 21)
+#define SYSCFG_PMCSETR_ETH_SEL_GMII_MII	0
+#define SYSCFG_PMCSETR_ETH_SEL_RGMII	BIT(21)
+#define SYSCFG_PMCSETR_ETH_SEL_RMII	BIT(23)
+
+/*
+ * Get a global data pointer
+ */
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	char *mode;
+	const char *fdt_compat;
+	int fdt_compat_len;
+
+	if (IS_ENABLED(CONFIG_TFABOOT))
+		mode = "trusted";
+	else
+		mode = "basic";
+
+	fdt_compat = fdt_getprop(gd->fdt_blob, 0, "compatible",
+				 &fdt_compat_len);
+	log_info("Board: stm32mp1 in %s mode (%s)\n", mode,
+		 fdt_compat && fdt_compat_len ? fdt_compat : "");
+
+	return 0;
+}
+
+static int get_led(struct udevice **dev, char *led_string)
+{
+	char *led_name;
+	int ret;
+
+	led_name = fdtdec_get_config_string(gd->fdt_blob, led_string);
+	if (!led_name) {
+		log_debug("could not find %s config string\n", led_string);
+		return -ENOENT;
+	}
+	ret = led_get_by_label(led_name, dev);
+	if (ret) {
+		log_debug("get=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int setup_led(enum led_state_t cmd)
+{
+	struct udevice *dev;
+	int ret;
+
+	if (!CONFIG_IS_ENABLED(LED))
+		return 0;
+
+	ret = get_led(&dev, "u-boot,boot-led");
+	if (ret)
+		return ret;
+
+	ret = led_set_state(dev, cmd);
+	return ret;
+}
+
+static void __maybe_unused led_error_blink(u32 nb_blink)
+{
+	int ret;
+	struct udevice *led;
+	u32 i;
+
+	if (!nb_blink)
+		return;
+
+	if (CONFIG_IS_ENABLED(LED)) {
+		ret = get_led(&led, "u-boot,error-led");
+		if (!ret) {
+			/* make u-boot,error-led blinking */
+			/* if U32_MAX and 125ms interval, for 17.02 years */
+			for (i = 0; i < 2 * nb_blink; i++) {
+				led_set_state(led, LEDST_TOGGLE);
+				mdelay(125);
+				WATCHDOG_RESET();
+			}
+			led_set_state(led, LEDST_ON);
+		}
+	}
+
+	/* infinite: the boot process must be stopped */
+	if (nb_blink == U32_MAX)
+		hang();
+}
+
+/* touchscreen driver: only used for pincontrol configuration */
+static const struct udevice_id goodix_ids[] = {
+	{ .compatible = "goodix,gt9147", },
+	{ }
+};
+
+U_BOOT_DRIVER(goodix) = {
+	.name		= "goodix",
+	.id		= UCLASS_NOP,
+	.of_match	= goodix_ids,
+};
+
+/* board dependent setup after realloc */
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = STM32_DDR_BASE + 0x100;
+
+	if (CONFIG_IS_ENABLED(DM_GPIO_HOG))
+		gpio_hog_probe_all();
+
+	if (CONFIG_IS_ENABLED(LED))
+		led_default_state();
+
+	setup_led(LEDST_ON);
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	char *boot_device;
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	const void *fdt_compat;
+	int fdt_compat_len;
+	int ret;
+	u32 otp;
+	struct udevice *dev;
+	char buf[10];
+
+	fdt_compat = fdt_getprop(gd->fdt_blob, 0, "compatible",
+				 &fdt_compat_len);
+	if (fdt_compat && fdt_compat_len) {
+		if (strncmp(fdt_compat, "st,", 3) != 0) {
+			env_set("board_name", fdt_compat);
+		} else {
+			char dtb_name[256];
+			int buf_len = sizeof(dtb_name);
+
+			env_set("board_name", fdt_compat + 3);
+
+			strlcpy(dtb_name, fdt_compat + 3, buf_len);
+			buf_len -= strlen(fdt_compat + 3);
+			strlcat(dtb_name, ".dtb", buf_len);
+			env_set("fdtfile", dtb_name);
+		}
+	}
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+
+	if (!ret)
+		ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_BOARD),
+				&otp, sizeof(otp));
+	if (!ret && otp) {
+		snprintf(buf, sizeof(buf), "0x%04x", otp >> 16);
+		env_set("board_id", buf);
+
+		snprintf(buf, sizeof(buf), "0x%04x",
+			 ((otp >> 8) & 0xF) - 1 + 0xA);
+		env_set("board_rev", buf);
+	}
+#endif
+
+	/* Check the boot-source to disable bootdelay */
+	boot_device = env_get("boot_device");
+	if (boot_device &&
+	    (!strcmp(boot_device, "serial") || !strcmp(boot_device, "usb")))
+		env_set("bootdelay", "0");
+
+	return 0;
+}
+
+enum env_location env_get_location(enum env_operation op, int prio)
+{
+	u32 bootmode = get_bootmode();
+
+	if (prio)
+		return ENVL_UNKNOWN;
+
+	switch (bootmode & TAMP_BOOT_DEVICE_MASK) {
+#ifdef CONFIG_ENV_IS_IN_MMC
+	case BOOT_FLASH_NOR:
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		return ENVL_MMC;
+#endif
+#ifdef CONFIG_ENV_IS_IN_EXT4
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		return ENVL_EXT4;
+#endif
+#ifdef CONFIG_ENV_IS_IN_UBI
+	case BOOT_FLASH_NAND:
+	case BOOT_FLASH_SPINAND:
+		return ENVL_UBI;
+#endif
+#ifdef CONFIG_ENV_IS_IN_SPI_FLASH
+	case BOOT_FLASH_NOR:
+		return ENVL_SPI_FLASH;
+#endif
+	default:
+		return ENVL_NOWHERE;
+	}
+}
+
+#if defined(CONFIG_ENV_IS_IN_EXT4)
+const char *env_ext4_get_intf(void)
+{
+	u32 bootmode = get_bootmode();
+
+	switch (bootmode & TAMP_BOOT_DEVICE_MASK) {
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		return "mmc";
+	default:
+		return "";
+	}
+}
+
+const char *env_ext4_get_dev_part(void)
+{
+	static char *const dev_part[] = {"0:auto", "1:auto", "2:auto"};
+	u32 bootmode = get_bootmode();
+
+	return dev_part[(bootmode & TAMP_BOOT_INSTANCE_MASK) - 1];
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	return 0;
+}
+#endif
+
+static void board_copro_image_process(ulong fw_image, size_t fw_size)
+{
+	int ret, id = 0; /* Copro id fixed to 0 as only one coproc on mp1 */
+
+	if (!rproc_is_initialized())
+		if (rproc_init()) {
+			log_err("Remote Processor %d initialization failed\n",
+				id);
+			return;
+		}
+
+	ret = rproc_load(id, fw_image, fw_size);
+	log_err("Load Remote Processor %d with data@addr=0x%08lx %u bytes:%s\n",
+		id, fw_image, fw_size, ret ? " Failed!" : " Success!");
+
+	if (!ret)
+		rproc_start(id);
+}
+
+U_BOOT_FIT_LOADABLE_HANDLER(IH_TYPE_COPRO, board_copro_image_process);
diff --git a/board/bytesatwork/common b/board/bytesatwork/common
new file mode 120000
index 0000000000..fea1e658d7
--- /dev/null
+++ b/board/bytesatwork/common
@@ -0,0 +1 @@
+../st/common
\ No newline at end of file
-- 
2.39.2

